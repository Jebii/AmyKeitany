GETTING STARTED WITH THE RASPBERRY PI

ALL ABOUT THE RASPBERRY PI 2 MODEL B
-It delivers x6 processing capacity of the previous models
-has an upgraded Broadcom BCM2836 processor that is a powerful ARM Cortex-A7 based quad-core processor that runs at 900MHz
-the memory is 1GB

    SPECS
    -Chip: Broadcom BCM2836 SoC
    -Core architecture: Quad-core ARM Cortex-A7
    -CPU: 900MHz
    -GPU: Dual Core VideoCore IV Multimedia Co-Processor
      	Provides Open GL ES 2.0, hardware-accelerated OpenVG, and 1080p30
      	H.264 high-profile decode
      	Capable of 1 Gpixel/s, 1.5Gtexel/s or 24 GFLOPs with texture filtering
      	DMA infrastructure
    -MEMORY: 1GB LPDDR
    -OS: Boots from Micro SD card, Raspbian
    -DIMENSION: 85x56x17mm
    -POWER: Micro USB socket 5V, 2A
    -VIDEO & AUDIO OUTPUT: HDMI
    -GPIO CONNECTOR: 40-pin 2.54mm (100 mil) expansion header;2x20 strip... 27 GPIO pins as well as +3.3V, +5V & GND supply lines
    -CAMERA CONNECTOR: 15pin MIPI Camera Serial Interface (CSI-2)
    -MEMORY CARD SLOT: Micro SDIO


INSTALLING RASPBIAN
    -Place SD card in SD Card Reader connect to comp/laptop.. go to www.raspberrypi.org
    -Get SD card formatter online to format the SD Card
    -Select the NOOBS and download the zip file into SD Card
    -PLace the SD Card into the raspberry pi and power up the pi
    -Select the preferred OS from the NOOBS installer dialog box that is Raspbian
    -then the pi will partition, install OS and configure booting
    -the pi will load, choose settings to configure and the pi will reboot
    - a color screen will appear and the pi will continue loading
    -and there we have it... the desktop environment will appear and the pi is ready to be used


CONFIGURING THE CAMERA MODULE
    -First update and upgrade the raspberry pi 'sudo apt-get update && upgrade'

    -run 'sudo raspi-config' select the camera option, select the enable option

    -select finish and reboot the raspberry pi

    -place camera in position to take photo or video

    -to see info of photo run 'raspistill'

    -to take a still photo 'raspistill -o image.jpg'

    -to take a video , run 'raspivid' to see info on videos

    -'raspivid -o videoname.h264 -t 10000'


CONFIGURING THE LAMP SERVER IN RASPBERRY PI (WE'LL HAVE TO REDO TO DEAL WITH UNCERTAINTIES)

Installing Apache:
    -Execute 'sudo apt-get install apache2'

    Test if it works:
    -got to browser enter 'http://127.0.0.1'
    -the browser should display 'It works!'

    Configuring Apache
    -all we need to do is place our HTML files in the /var/www directory, this is by default in ubuntu
    -to allow access by other users to this directory, use chmod command
    -Apache stores its configuration files in the /etc/apache2 directory, the main file is 'apache2.conf', in other distros it is the 'httpd.conf'
    -additional configurations are stored in the 'etc/apache2/mods-enable' and 'etc/apache2/sites-enable' this one is for virtual hosts
    -before any configuration changes always restart Apache cz info stored in the '.htaccess' files override info in the config files

    Starting, Stopping and Restarting Apache
    -when linux is booted, Apache automatically starts
    -to stop 'sudo /etc/init.d/apache2 stop'
    -to start 'sudo /etc/init.d/apache2 start'
    -to restart 'sudo /etc/init.d/apache2 restart'
    -when restarting Apache an error could occur showing that apache2 could not determine the server's fully qualified domain name..to fix this create a file 'fqdn' in '/etc/apache2/config.d/' and add the line 'ServerName localhost'

    //so for the above the error is solved by actually giving the server a name: 'localhost'


Installing PHP
    -execute 'sudo apt-get install php5'
   	 this could be in a number of possible places:
   		 -/usr/share/lintian/overrides/libapache-mod-php5
   		 -/usr/share/doc/libapache2-mod-php5
   	 or just do a 'cd / ; sudo find -iname libapache*'
    -then automatically php5 is installed in 'libapache-mod-php5'
    -to enable options of websites with dynamic images, install the packages 'sudo apt-get install php5-gd'
    -to complete the installation, restart Apache

Testing PHP
    -to verify successful installation, create a file in /var/www and name it 'test.php' and add
   	 <?php
   		 phpinfo ();
   	 ?>
    -go to 'http://127.0.0.1/test.php' an info on php shall be displayed

    Configuring PHP
    -edit the 'php.ini' found in the '/etc/php5/apache2'

    //interesting note
    	to change the name of your computer ie hostname
   	 /usr/hostname
   	 /usr/hosts

Installing MySQL
    -execute 'sudo apt-get install mysql-server'
    -add password for root user once prompted, this password shall be used to access the databases
    -install php5 module to use MySQL with php, 'sudo apt-get install php5-mysql'
    -restart Apache again to complete installation

Testing MySQL
    -Execute 'mysql -u root -p'
    -put password where prompted

Configuring MySQL
    -by default the MySQL database can be accessed by 'localhost'
    -to give a different IP address, edit the MySQL config file '/etc/mysql/my.cnf' and add
   	 bind-address = localhost
    -Navicat is a program used to connect and edit databases
    -can also use PHPmyadmin as a web interface


    -Install PhpMyAdmin Web Interface
    -Install phpmyadmin 'sudo apt-get install phpmyadmin'
    -Configure phpmyadmin, choose server i.e apache2
    a dialog box to configure a database will appear, choose no, cz we shall configure a database later

    -web browsing accessibilities,so that the apache can read the configurations
    'sudo cp /etc/phpmyadmin/apache.conf /etc/apache2/conf-available'

    'sudo mv /etc/apache2/conf-available/apache.conf /etc/apache2/conf-available/phpmyadmin.conf'
    'sudo a2enconf phpmyadmin'
    the response should be 'conf phpmyadmin already enabled'


    'sudo service apache2 restart'

    - 'sudo dpkg-reconfigure mysql-server-5.6'    setting the password
    - 'sudo mysql_secure_installation'    for installation



    -Using PhpMyAdmin
    point the browser to the server IP or virtual domain name and login to phpMyAdmin using root account

    'mysql -u root -p'
    'mysql> CREATE DATABASE IF NOT EXISTS databasename;'
    'mysql> CREATE USER lamarr@localhost IDENTIFIED BY "username";'
    'mysql> GRANT ALL PRIVILEGES ON wordpress.*TO lamarr@localhost;'
    'mysql> FLUSH PRIVILEGES;'
    'mysql> quit

    -get IP address of this comp 'ifconfig'....get IP addr and type 'addr/phpmyadmin' in browser
    log in
    create database, check privileges
    add user
    -------------------------------------------------------------------------------------------------------------------
Here's an alternative to lamp installation
   	 'sudo apt-get install apache2 php5 libapache2-mod-php5'
   	 'sudo apt-get install mysql-server mysql-client php5-mysql'

SETTING UP THE PIR MOTION SENSOR
-PIR(Passive infrared) sensor is a pyroelectric device that detects motion by sensing changes in the infrared levels emitted by the surrounding objects. Motion is detected by checking for a sudden change in the IR pattern. When motion is detected the sensor outputs a high signal on its output pin.

    Features
    -detects a person up to approx 30ft
    -jumper selects normal operation or reduced sensitivity
    -source current is up to 12mA @ 3V, 23mA @ 5V
    -onboard LEDs light up for fast visual feedback
    -has mounting holes
    -3-pin SIP headers
    -requires a warm up time of up to 40secs due to 'settling time'

-We should get the raspberry pi library for eagle to get the schematic of the project

    -we create a c file to code the control of the PIR, more of testing its functionality
   	 #include<bcm2835.h>
   	 #include<stdlib.h>
   	 #include<stdio.h>
   	 
   	 #define PIN RPI_GPIO_P1_15

   	 int main(int argc, char **argv)
   	 {
   		 if (!bcm2835_init())
   			 return 1;

   		 bcm2835_gpio_fsel(PIN, BCM2835_GPIO_FSEL_INPT);
   		 printf("Hello. I see you\n");

   		 while (1)
   		 {
   			 if (bcm2835_gpio_lev(PIN))
   			 {
   				system("raspistill -q 5 -o picture.jpg -t 1 -th 0:0:0");
   				printf("Captured your photo!\n");
   				while (bcm2835_gpio_lev(PIN));   			 
   			 }
   			 bcm2835_delay(10);
   		 }
   	 }
    -bcm2835 is the library that allows control of the gpio pins using the C compiler
-we should upload library files to the raspberry pi
    - -q is the quality and -o is for output.. -th is for thumbnail parameter... 0:0:0 is for photos taken in lapse time
    
-look into how to take photos in small periods of time to create a video

    -to compile the C code 'gcc -o filename.c -l bsm2835'
    then 'sudo ./filename-with-C.code'
How to use a Raspberry Pi to find out who's been in your room: make a parent detector that use motion detection to trigger video recording via the Raspberry Pi camera module

    About the Passive Infrared (PIR) motion sensor
In this project, we are going to be using a Passive Infrared (PIR) motion sensor. You have probably seen these before: they are often used in burglar alarm systems (the sensors placed in the corners of rooms are typically PIR ones). All objects whose temperatures are above absolute zero emit infrared radiation. Infrared wavelengths are not visible to the human eye, but they can be detected by the electronics inside one of these modules.

The sensor is regarded as passive because it doesn't send out any signal in order to detect movement. It adjusts itself to the infrared signature of the room it's in and then watches for any changes. Any object moving through the room will disturb the infrared signature, and will cause a change to be noticed by the PIR module.

What we're interested in are the three pins on it: we can connect those to the Raspberry Pi GPIO pins. One pin is for +5 volts, one pin is for ground and the other is the sensor pin (the middle pin on our Pi). This sensor pin will receive power whenever motion is detected by the PIR module. We can then see that happening on the Raspberry Pi and take action accordingly.

    Connect the PIR motion sensor
Before booting your Raspberry Pi, connect the PIR module to the Raspberry Pi. Using three female-to-female jumper cables, you'll need to connect each of the PIR sensor's connectors to the appropriate pins on the Raspberry Pi. Connect the top one (labelled VCC on the PIR sensor) to the 5V pin on the Raspberry Pi, connect the middle one (labelled OUT) to GPIO pin 4, and connect the bottom one (labelled GND) to a ground pin marked GND.

    Test the PIR motion sensor
We're going to use the Python programming language to write some code that will detect movement and print out some text; we can extend the program to involve the camera board later on. When movement is detected the PIR motion sensor applies power to its OUT pin, which we have connected to GPIO pin 4 on the Pi. So in our code we just need to continually check pin 4 to see if it has power or not. If a pin has power we call it HIGH and if not we call it LOW.

The program is pretty simple. We will first set up the Raspberry Pi GPIO pins to allow us to use pin 4 as an input; it can then detect when the PIR module sends power. We need to check the pin continually for any changes, so we use a while True loop for this. This is an infinite loop so the program will run continuously unless we stop it manually with Ctrl + C.

We then use two Boolean variables (True or False) for the previous and current states of the pin, the previous state being what the current state was the preceding time around the loop. Inside the loop we compare the previous state to the current state to detect when they're different. We don't want to keep displaying a message if there has been no change.

Firstly create a blank Python file with the following command:
   		 'nano pytest.py'
Enter the code:
   		 import RPi.GPIO as GPIO
   		 import time

   		 sensor = 4

   		 GPIO.setmode(GPIO.BCM)
   		 GPIO.setup(sensor, GPIO.IN, GPIO.PUD_DOWN)

   		 previous_state = False
   		 current_state = False

   		 while True:
   		 	time.sleep(0.1)
   		 	previous_state = current_state
   		 	current_state = GPIO.input(sensor)
   		 	if current_state != previous_state:
   			 new_state = "HIGH" if current_state else "LOW"
   			 print("GPIO pin %s is %s" % (sensor, new_state))

Press Ctrl + O to save and Ctrl + X to quit.
run the Python file:
   		 'sudo python3 pirtest.py'

If you start moving or waving the sensor pin will go HIGH. Keep on waving and it will stay HIGH, and only go back to LOW if you keep still again. If you see the sensor behave like this, then everything is working correctly.

On the PIR module you should see two orange components with sockets that fit a Phillips screwdriver (see above). These are called potentiometers: they allow you to adjust the sensitivity of the sensor and the detection time. You should begin by setting the sensitivity to max and the time to min, but you can vary this later if you wish.

Setting up the camera
Before you can begin the project, you'll need to connect the camera. You should do this before you boot the Pi, or, if your Pi is running, you should stop it by entering sudo-halt. set up the camera mount. This will enable you to aim the camera at the right part of the room.
test the camera is working using the following command:
   		 'raspivid -t 0'


    Program the camera to preview on movement
let's just make our program display what the camera can see when movement is detected.

Make a copy of the previous program and we'll use that for this step
   		 'cp pirtest.py pirCamera.py'

use the following command to edit the file:
   		 'nano pirCamera.py'

We first need to add the import picamera statement at the top; this allows your program to access the pre-made code which can control the camera module. We then declare the camera object cam, which provides all the camera control functions that we need to use. Then inside the while loop where we print the HIGH or LOW message, we can test to see if current_state is HIGH or True (meaning that movement is detected); we can then start or stop the camera preview accordingly

   		 import RPi.GPIO as GPIO
   		 import time
   		 import picamera  # new

   		 sensor = 4

   		 GPIO.setmode(GPIO.BCM)
   		 GPIO.setup(sensor, GPIO.IN, GPIO.PUD_DOWN)

   		 previous_state = False
   		 current_state = False

   		 cam = picamera.PiCamera()  # new

   		 while True:
   		 	time.sleep(0.1)
   		 	previous_state = current_state
   		 	current_state = GPIO.input(sensor)
   		 	if current_state != previous_state:
   			 new_state = "HIGH" if current_state else "LOW"
   			 print("GPIO pin %s is %s" % (sensor, new_state))
   			 if current_state:  # new
   			 	cam.start_preview()
   			 else:
   			 	cam.stop_preview()

Press Ctrl + O to save and Ctrl + X to quit. To run the program use the following command
   		 'sudo python3 pirCamera.py'


   	 Recording to a file and playing back
add a bit more code to allow us to record to a file for playback at a later stage. If there are multiple intruders in your room, you want to be able to capture them all and not just the most recent one. To do that, we need a way to generate a new file name automatically each time movement is detected. The easiest and safest way to do this is to make a file name out of the date and time.

This uses the format of YEAR-MONTH-DAY_HOUR.MINUTE.SECOND.h264; h264 refers to the format the video will be recorded in. It's the same as the format used by YouTube.

We need to import the datetime Python module and write a function to generate the filename. See get_file_name below: this uses the string from time function to insert the values from the current time into the specified string format. Then you simply use the commands to start and stop the recording using the generated file name. These should happen at the same time as the preview commands respectively.
   		 'nano pirCamera.py'
then update:
   		 import RPi.GPIO as GPIO
   		 import time
   		 import picamera
   		 import datetime  # new

   		 def get_file_name():  # new
   		 	return datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S.h264")

   		 sensor = 4

   		 GPIO.setmode(GPIO.BCM)
   		 GPIO.setup(sensor, GPIO.IN, GPIO.PUD_DOWN)

   		 previous_state = False
   		 current_state = False

   		 cam = picamera.PiCamera()

   		 while True:
   		 	time.sleep(0.1)
   		 	previous_state = current_state
   		 	current_state = GPIO.input(sensor)
   		 	if current_state != previous_state:
   			 new_state = "HIGH" if current_state else "LOW"
   			 print("GPIO pin %s is %s" % (sensor, new_state))
   			 if current_state:
   			 	fileName = get_file_name()  # new
   			 	cam.start_preview()
   			 	cam.start_recording(fileName)  # new
   			 else:
   			 	cam.stop_preview()
				cam.stop_recording()

Press Ctrl + O to save and Ctrl + X to quit. To run the program use the following command:
   		 'sudo python3 pirCamera.py'

Press Ctrl + C when you want to exit.

    	 
    Playback
If you now use the ls command you should see that a few files have been generated. You can use the following command to playback a file. Replace <file> with the filename you wish to play.
   	 'omxplayer <file> -o hdmi'

CONFIGURING SSH ON RASPBERRY PI
-SSH is SecureShell.. allows exchange of data through cryptography, communication btwn two computers through the internet. Used to log into a remote machine in this case the raspberry pi.
-check out 'www.portforward.com' for more info on how to SSH from a network outside of local network

    -Download PuTTY from 'www.putty.com' on laptop or desktop
    -also download xming for windows from 'sourceforge.net'
    -run the xming.exe
    -in PuTTY configuration dialog box...first get the raspberry pi's IP address 'sudo raspi-config' and select ssh to enable the ssh server..then exit... reboot the pi.. run ifconfig to get the ip address of pi in the network
    - fill in the ip address in the PuTTY dialog box and leave the port number to be 22...make sure the setting is at ssh
    -click open... login with raspberry pi credentials
    -and the terminal will appear as it is in the pi
    -the xming will then display the desktop environment of the pi.
    
    -for linux run 'sudo apt-get putty' on terminal
    -access the putty client server from the start menu
    open the program.. on the dialog box.. put ip address for pi.. set to ssh..and open session
    -log in with username as 'pi' and password as 'raspberry'
    -The default command to start a ssh session with X forwarding enabled is:
   	 ssh -X target.machine.address

SETTING THE IP TO BE A WEBSERVER and WEBCAM SERVER
    -run 'sudo apt-get update && sudo apt-get upgrade
    -sudo apt-get install ca-certificates... to update firmware
    -sudo apt-get install git-core
    -get rpi update sudo apt-get http://goo.gl/1BOfJ -O /usr/bin/rpi-update && sudo chmod +x /usr/binrpi-update....downloads and sets to executable
    -sudo rpi-update....updates all the firmware
    -reboot raspberry pi with 'sudo shutdown -r now'

    -enabling us to run websites...check the lamp config section
    
    -set up the SFTP from laptop to raspberry pi using Filezilla on laptop...

    ---------------------------------------------------------------------------
    -run 'sudo apt-get update && upgrade'
    -'sudo apt-get install motion'
    -'sudo nano /etc/motion/motion.conf.. set daemon to on and webcam-localhost to off, webcammax-rate to 100, image width to 640 and image height to 480.. frame rate to 100     
    -select 'sudo nano /etc/default/motion and put option yes in start-motion daemon
    -start webcam 'sudo service motion start .. and the image will show on the browser
    -to stop webcam 'sudo service motion stop'
    

    -for raspberry pi camera 'sudo apt-get install rpi-update'
    -then 'sudo rpi-upgrade'...and reboot the raspberry pi
    -Install Dropbox 'wget https://www.dropbox.com/s/xdfcxm5hu71s97d/motion-mmal.tar.gz'
    -extract the file 'tar -zxvf mmotion-mmal.tar.gz'
    -enter the config file 'sudo nano motion-mmalcam.conf'
    -change the image width and height, frame rate to 100 ..and set the target_dir 'enter path of made dir'
    -set output pictures to off
    -log file to dirpath/motion.log
    -stream maxrate to 100
    -to run on browser './motion -n -c motion-mmalcam.conf'
    -video will show on browser
    
    -create script for start motion... create nano file called startmotion, enter the command
   	 #!/bin/sh
   	 nohup "directory path"/mmal/motion -n -c "dirpath"/mmal/motion-mmalcam.conf 1>/dev/null $/null 2>&1 </dev/null

    -for stop motion.. create nano file stopmotion and enter the command
   	 #!/bin/sh
   	 killall motion
    -make the files executable.. 'sudo chmod 755 startmotion' .. 'sudo chmod 755 stopmotion'
    -to simply stop or start the script './startmotion' and './stopmotion'
    -for external access.. use ssh

INSTALLING OPENCV,DROPBOX AND PYTHON.SDK
    ***Installing this brought issues,though we don't need it for now..thought it would have been interesting to use...maybe later because of time)Install openCV:
   	 -'sudo apt-get update'... 'sudo apt-get upgrade'.. 'sudo rpi-update'
   	 -install developer tools and packages... 'sudo apt-get install build-essential cmake pkg-config'
   	 -install necessary image I/O packages.. 'sudo apt-get install libjpeg8-dev libtiff4-dev libjasper-dev libpng12-dev'
   	 -install the GTK development library to build a GUI to view images on screen.. 'sudo apt-get install libgtk2.0-dev'
   	 -instal necessary video I/O packages.. 'sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev'
   	 -install libraries used to optimize various operations of OpenCV ..'sudo apt-get install libatlas-base-dev gfortran
   	 -install pip.. 'wget https://bootstrap.pypa.io/get-pip.py'... 'sudo python get-pip.py'
   	 -install virtual environment.. 'sudo pip install virtualenv virtualenvwrapper'.. 'sudo rm -rf ~/.cache/pip'
   	 -update ~/.profile file.. 'export WORKON_HOME=$HOME/.virtualenv'.. 'source /usr/local/bin/virtualenvwrapper.sh'
   	 -reload .profile 'source ~/.profile'
   	 -create vision virtual environment 'mkvirtualenv cv'
   	 -install Python 2.7 development tools 'sudo apt-get install python2.7-dev' ...OpenCV 2.4.X does not support Python 3
   	 -install NumPy because OpenCV Python bindings represent images as multidimensional arrays.. 'pip install numpy'
   	 -Download openCV and unpack 'wget -O opencv-2.4.10.zip http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.4.10/opencv-2.4.10.zip/download'... 'unzip opencv-2.4.10.zip'... 'cd opencv-2.4.10'
   	 -set up the build 'sudo mkdir build'.. 'cd build'.. 'cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D BUILD_NEW_PYTHON_SUPPORT=ON -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON'
   	 -compile openCV 'make' ,,make sure you are in the virtual environment
   	 -install OpenCV.. 'sudo make install'.. 'sudo ldconfig'
   	 -OpenCV should be installed in '/usr/local/lib/python2.7/site-packages'
   	 -to utilize OpenCV within the virtual environment, we sym-link OpenCV into 'site-packages' directory
   		 'cd ~/.virtualenvs/cv/lib/python2.7/site-packages'
   		 'ln -s /usr/local/lib/python2.7/site-packages/cv2.so cv2.so'
   		 'ln -s /usr/local/lib/python2.7/site-packages/cv.py cv.py'
   	 -finally we test OpenCV 'workon cv'.. 'python'.. '>>>impost cv2'.. '>>>cv2.__version__' ''2..4.10''   ****
    
    Installing the python SDK
    To make things as easy as possible, we have several platform SDKs you can import into your development environment to get up and running quickly. The SDKs contain platform-specific libraries that wrap the raw HTTP calls to the Dropbox API. They are designed to shorten the    	 distance between your application and integrating Dropbox.
   	 
   	 -download and uncompress the SDK ‘wget https://www.dropbox.com/developments/downloads/sdks/core/python/dropbox-python-sdk-2.2.0.zip’
   	-unzip dropbox zip folder
-to install dropbox module and dependencies run 'sudo python setup.py install'
   	 -alternatively 'sudo pip install dropbox'.. from this we can use the Core API methods of dropbox

    -to enable system to upload security photos on dropbox    
    -to upload your home security photos to your personal Dropbox, you’ll need to register with the Dropbox Core API to obtain your public and private API keys
    Create app on dropbox website under dropbox account.. configure required setting app folder name, access permissions, app_key app_secret


Using the Core API in Python
The Core API is based on HTTP and OAuth and provides low-level calls to access and manipulate a user's Dropbox account.

If you want to follow along, first register a new app on the App Console. You'll need the app key to access the Core API. Then install the Python SDK and you'll be ready to go.

Authenticating your app

The Core API uses OAuth v2, but the Python SDK will take care of most of it so you don't have to start from scratch.
You'll need to provide your app key and secret to the new DropboxOAuth2FlowNoRedirect object.

   		 # Include the Dropbox SDK
   		 import dropbox

   		 # Get your app key and secret from the Dropbox developer website
   		 app_key = 'INSERT_APP_KEY'
   		 app_secret = 'INSERT_APP_SECRET'

   		 flow = dropbox.client.DropboxOAuth2FlowNoRedirect(app_key, app_secret)

Now we're all set to start the OAuth flow. The OAuth flow has two parts:

	Ask the user to authorize linking your app to their Dropbox account.
	Once authorized, exchange the received authorization code for an access token, which will be used for calling the Core API.

We'll start by using the DropboxOAuth2FlowNoRedirect object to generate an authorization URL with the start method.

With the authorization URL in hand, we can now ask the user to authorize your app.
   		 # Have the user login and authorize this token
   		 authorize_url = flow.start()
   		 print '1. Go to: ' + authorize_url
   		 print '2. Click "Allow" (you might have to login first)'
   		 print '3. Copy the authorization code.'
   		 code = raw_input("Enter the authorization code here: ").strip()

Once the user has delivered the authorization code to our app, we can exchange that code for an access token via finish:
   		 #This will fail if the user enters an invalid authorization code
   		 access_token, user_id = flow.finish(code)

The full code:
 import RPi.GPIO as GPIO
   		 import time
   		 import picamera
   		 import datetime  
		 import subprocess
		 import dropbox
		 import os

		#get the app_key and secret from dropbox developer website
		app_key = “insert app key”
		app_secret=”insert app secret”

   		 def get_file_name(): 
   		 	return datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S.h264")
	
		def dropboxAuth():
			accessTokenFileOverwrite = open(“accessToken.txt”, “w+”)

			flow = dropbox.client.DropboxOAuth2FlowNoRedirect (app_key, app_secret)
			authorize_url = flow.start()

		#here the user login and authorize this token
		authorize_url = flow.start()
		print ‘’1. Go to: ’ + authorize_url
		print ‘’2. Click “Allow” (you might need to log in first) ’ 
		print ‘’3. Copy the authorization code.’ 
		code = raw_input(“Enter the authorization code here: ”). strip()

		try:
			#this will fail if the user enters an invalid authorization code
			aceess_token, user_id = flow.finish(code)
			accessTokenFileOverwrite.write(access_token)
		except:
			print “failed authorization, restart”
accesTokenFileOverwrite.close()
os.remove(“accessToken.txt”)
accessTokenfileOverwrite.close()

def dropboxUpload(fileToUpload):
	if not os.path.isfile(“accessToken.txt”):
		dropboxAuth()

	#get access token from file
	accessTokenFileread = open(“accessToken.txt”, “r”)
	acsess_token = accessTokenFileRead.read()
	accessTokenFileread.close()

	#make client
	client = dropbox.client.DropboxClient (access_token)

	#upload file
	fileToUploadObject = open(fileToUpload, “rb”)
	response = client.put_file(fileToUpload, fileToUploadObject)
	fileToUploadOblect.close()

   		 sensor = 4

   		 GPIO.setmode(GPIO.BCM)
   		 GPIO.setup(sensor, GPIO.IN, GPIO.PUD_DOWN)

   		 previous_state = False
   		 current_state = False

   		 cam = picamera.PiCamera()

   		 while True:
   		 	time.sleep(0.1)
   		 	previous_state = current_state
   		 	current_state = GPIO.input(sensor)
   		 	if current_state != previous_state:
   			 new_state = "HIGH" if current_state else "LOW"
   			 print("GPIO pin %s is %s" % (sensor, new_state))
   			 if current_state:
   			 	fileName = get_file_name()  
				print “Starting recording…”
   			 	cam.start_preview()
   			 	cam.start_recording(fileName)  
				print (fileName)
   			
 else:
   			 	cam.stop_preview()
				cam.stop_recording()
				print ”Stopped Recording ”
				print “Sending Mail Notification...”
				subprocess.call(“mail -s ‘Motion Detected’ jebiikeitany@gmail.com < /home/pi/message.txt”, shell=True)
				print “Complete”
				print” Uploading footage to Dropbox...”
				dropboxUpload(fileName)
				print”Complete”

H.264 intra frame compression
H.264 contains a number of new features that allow it to compress images much more efficiently than JPG.
New transform design
That can be usually performed on “DC” coefficients to obtain even more compression in smooth regions.
There is also an optimized quantization and two possible zig-zag pattern for Run Length Encoding of transformed coefficients.
Intra-frame compression
H.264 introduces complex spatial prediction for intra-frame compression.
There are also 4 prediction modes for smooth color zones (16×16 blocks). 
Improved quantization
A new logarithmic quantization step is used (compound rate 12%). It’s also possible to use Frequency-customized quantization scaling matrices selected by the encoder for perceptual-based quantization optimization.
Inloop deblocking filter
An adaptive deblocking filter is applied to reduce eventual blocking artifacts at high compression ratio.
Advanced Entropy Coding
H.264 can use the state of the art in entropy coding: Context Adaptive Binary Arithmetic Coding (CABAC) which is much more efficient than the standard Huffman coding used in JPG.

Converting the h264 format to jpg for easier viewing
	By utilizing the services of an online converter,that is http://www.online-convert.com/, we are able to convert the catured photos into the jpg format. The online converter also provides features like attaching the converted image to an email as well as uploading it to google drive and dropbox as well. 

INTERFACING THE RASPBERRY PI WITH GSM SIM900 TTL USING UART COMMUNICATION
Most of the people are familiarized with the dial up modem as it a common device for landline telephone network used in homes and offices. It is a wired network which has got its own limitations in the embedded area. GSM modem is introduced to rectify the main limitation of the dial up modem based on its acceptance of a sim card. It is almost equivalent to a mobile communication system as operates over a subscription to a mobile operator. From the mobile operator perspective, a GSM modem looks just like a mobile phone.Using the transmission and reception pins, a modem can receive and send the messages and it could be interfaced with the PC or to a microcontroller. This property makes the modem to exist in a relevant position on embedded applications. 

	Raspberry Pi is a high end embedded device, so an interface with a GSM modem will results in the invention of an intelligent system. As the Raspberry Pi finds its own applications in image, video and audio processing, the modem interface could develop a new path in the field of home automation, surveillance etc. In this project interface a GSM/GPRS TTL UART Modem-SIM900A with Raspberry Pi2 and to send and receive message through it.
Insert a sim card into the GSM modem and make the suitable connections as shown in the figure. A suitable factor that should keep in mind is that, the sim used in the module should have enough balance to send the sms and it should be kept in a place having appropriate range for that particular network. The transmission and reception pins should be connected in a reverse order and the ground pins must be shorted.  Power up the GSM module and wait for few seconds for sim initialization.

	Now we need to send and receive messages through this modem with the help of a python script. In the code, import the proper libraries and enable the serial communication. Modem control is done through AT commands, so suitable commands should be transmitted to the modem for each purpose and the modem will respond to these commands by transmitting suitable messages that should received and display it on the python shell.

		
ENABLING THE GSM TO SEND NOTIFICATION AND MAKE CALL TO USER
  	A sample python code for sending a message through raspberry pi and gsm modem is given below:

		import serial
import RPi.GPIO as GPIO      
import os, time
 
GPIO.setmode(GPIO.BOARD)    
 
# Enable Serial Communication
port = serial.Serial("/dev/ttyAMA0", baudrate=9600, timeout=1)
 
# Transmitting AT Commands to the Modem
# '\r\n' indicates the Enter key
 
port.write('AT'+'\r\n')
rcv = port.read(10)
print rcv
time.sleep(1)
 
port.write('ATE0'+'\r\n')      # Disable the Echo
rcv = port.read(10)
print rcv
time.sleep(1)
 
port.write('AT+CMGF=1'+'\r\n')  # Select Message format as Text mode
rcv = port.read(10)
print rcv
time.sleep(1)
 
port.write('AT+CNMI=2,1,0,0,0'+'\r\n')   # New SMS Message Indications
rcv = port.read(10)
print rcv
time.sleep(1)
 
# Sending a message to a particular Number
 
port.write('AT+CMGS=""'+'\r\n')
rcv = port.read(10)
print rcv
time.sleep(1)
 
port.write('Hello User'+'\r\n')  # Message
rcv = port.read(10)
print rcv
 
port.write("\x1A") # Enable to send SMS
for i in range(10):
    rcv = port.read(10)
    print rcv


SETTING UP THE MAIL SERVER AND FTP SERVER
    HOW TO SEND EMAIL ON RASPBERRY PI WITH SSMTP
    -SSMTP is a program to deliver an email from a local computer to a configured mail host (mail hub). It is not a mail server but it is using sendmail and does not receive mail, expand aliases or manage a queue. One of its      primary uses is for forwarding automated email (like system alerts) off your machine and to an external email address.
    With SSMTP on Raspberry Pi you can use command or text email draft to send an email from Raspberry Pi.

    -install packages 'sudo apt-get update'...'sudo apt-get install ssmtp'
    -configure Ssmtp 'sudo nano /etc/ssmtp/ssmtp.conf'.. edit the following
   	 hostname=lamarr
   	 UseSTARTTLS=YES
   	 AuthUser=jebiikeitany@gmail.com
   	 AuthPath=password_on_gmail

   	 From: address
   	 FromLineOverride=YES

    -testing.. create text file on cd /var/tmp nano test mail.txt.... edit using proper formatting of ssmtp
    'To: destination.address@gmail.com From: your .email@gmail.com Subject: This is a test mail body of email
    -send an email to destination address 'ssmtp destination.address@gmail.com < test mail.txt
----------------------------------------------------------------------------------------------------------------------------
There are many cases when it can be very useful to be able to send emails from the Raspberry Pi to arbitrary recipients. This is not the same as having a real MTA running on the Pi (like Sendmail, Postfix, Exim, QMail, etc.), which can also receive and store emails. In the following we are only going to cover the possibility of sending emails, not receiving. In most cases this is enough, as people tend to use GMail, Yahoo! Mail and other major email service providers and they store their emails on the servers of these providers. Still, sending out emails from the Raspberry Pi can come in handy in many situations. For example, you could have some sensors connected to the GPIO pins of the Pi and you could program the Pi to send you an email when the temperature in the room rises above or drops below certain threshold values, when a gas sensor registers unwanted gas leaks or when the measured voltage of a monitored battery becomes too low. You could also have your Pi send you daily or weekly emails with summarized system data. Or maybe you could connect a webcam to the Raspberry Pi and set up some motion detection software, which would send you an email as soon as it detects motion in a given area of your house. Maybe we don’t even need to go this far. Maybe you are hosting a WordPress website on your Raspberry Pi and you would like to provide your readers with the possibility to subscribe to the posts. This all means that the Pi needs to be able to send out emails, which, unfortunately, can be complicated to accomplish.
In order to achieve this we are going to install a piece of software called SSMTP, which is a simple tool for sending emails. We are also going to configure PHP in a way which is going to make it possible to send emails from inside PHP scripts. This way it’s going to be easy for web applications (like WordPress plugins) to send mails to chosen recipients.
Many email servers today have very strict rules for accepting emails. For example if the email is not coming from a machine with a static IP address, they might classify the email as SPAM. We don’t want that to happen with the emails sent from the Raspberry Pi, so we are going to send the emails to a Google server, which will send them forward to the real recipients. In order to be able to accomplish this, you must have a GMail account.

Installing and configuring SSMTP

1. Make sure your repositories are up-to-date:

apt-get update

2. Install SSMTP and mail utilities:

apt-get install ssmtp

apt-get install mailutils

3. Edit the SSMTP configuration file:

nano /etc/ssmtp/ssmtp.conf

a) Mandatory lines:

root=postmaster
mailhub=smtp.gmail.com:587
hostname=lamarr
AuthUser=jebiikeitany@gmail.com
AuthPass=YourGMailPassword
UseSTARTTLS=YES

Be sure to specify the correct GMail username and password here, otherwise you will get authentication error

s.

If the hostname of your Raspberry Pi is different from “raspberrypi”, specify your actual host name here instead.

b) Optional lines:

rewriteDomain=your.domain

Specify this if you would like the outgoing emails to appear to be sent from your.domain (instead of from gmail.com).

FromLineOverride=YES

Specify this if you would like SSMTP to leave the From field of the emails untouched. 

4. Edit the SSMTP aliases file:

nano /etc/ssmtp/revaliases

This file contains data about the email accounts for existing Linux users in the format local_account:outgoing_address:mailhub[:port]

You should create one line for all the users in your system from which you plan to be able to send emails. For example:

root:root@your.domain:smtp.gmail.com:587
www-data:yourwebpagesname@your.domain:smtp.gmail.com:587

In case you wish to send out emails from a WordPress plugin, you must make sure that you have a line for the user www-data, which is the user under which WordPress runs.

5. Set the permissions of the SSMTP configuration file:

chmod 774 /etc/ssmtp/ssmtp.conf

The  permissions of the file /etc/ssmtp/ssmtp.conf determine  who will be able to send emails from the Raspberry Pi. By default this file is owned by the user root and the group of the file is also root. So if you want other users, like www-data to be able to send emails (which you definitely want if you’re using a WordPress plugin for example to send out emails), then you need to give read rights to the users who are not the owner of the file and not in the group of the file. The above permissions (774) mean that the owner (root) will be able to read/write/execute the file (7), the other users in the root group will be able to do the same (7) and the users which are not in the group will only have the right to read the file (4). For more details type chmod –help.

If you prefer not to allow every user on your system to send emails, then add the www-data user (or the user who you would like to grant permission for sending emails) to the root group and only give the rights to the users in this group:

sudo usermod -a -G root www-data
chmod 770 /etc/ssmtp/ssmtp.conf

Be careful though. Adding the www-data user to the root group might sometimes not be very safe, as it will allow your website to do many things on your system.

Sending emails from command line

Once you’re done with the above setup and configuration process, you can send emails very easily from command line, which is great because you can also put the sending into Bash scripts, which can be called by other applications running on your Pi. A simple example looks like this:

echo “Test text” | mail -s “Test Mail” jebiikeitany@example.com

The text “Test text” is sent to the email address targetperson@example.com (you may also specify multiple addresses separated by spaces) with the subject “Test Mail”. For more options type mail –help.

Enabling https and ssl for email requests
Use the somewhat hidden security feature:
sudo pip install 'requests[security]'
This installs following extra packages:
pyOpenSSL
ndg-httpsclient
pyasn1
Also install the following additional development packages 
sudo apt-get install python-dev libffi-dev libssl-dev packages.


    SETTING UP FTP SERVER WITH VSFTPD
    Vsftpd is secure, lightweight and very stable FTP server with advanced of feature. It is licensed under the GNU General Public    	 License. It supports IPV6 and SSL.
    FTP server allows you to transfer files between Raspberry Pi with your devices on the local network or even across the Internet

    -instal vsftpd 'sudo apt-get update' ... 'sudo apt-get install vsftpd'
    -configure by editing the vsftpd.conf file .. 'sudo nano /etc/vsftpd.conf'...
    -to run vsftpd as standalone mode.. Listen=on
    -listen on ipv6... Listen_ipv6=YES
    -disable anonymous ftp login... anonynous_enable=off
    -enable users to log in... local_enable=on
    -enable ftp to write changes to file.... write_enable=on
    -ftp banner login message.. ftpd_banner=Welcome to awesome ftp service
    -change default home directory.. local_root=home/pi
    -restart 'sudo service vsftpd restart'

    -testing.. install FTP client, that is Filezilla and connect to pi

